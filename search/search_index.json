{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Kuberenetes is an open-source platform for the systematic deployment, scaling and management of containerized workloads.</p> <p>The name Kubernetes originates from Greek and it translates to <code>Helmsman</code> or <code>Pilot</code> or <code>Captain</code> of a ship in English.</p> <p>It is often referred to as <code>K8s</code>, where <code>8</code> stands for the number of letters between <code>K</code> and <code>s</code>.</p>"},{"location":"#features-of-kubernetes","title":"Features of Kubernetes","text":"<ul> <li> <p>Rollouts and Rollbacks</p> <ul> <li>It rolls out changes to your workloads in a phased manner while monitoring your health to determine its readiness and liveness</li> <li>If the change applied is unable to attain the desired state, it will roll back the changes to their previous known healthy state</li> </ul> </li> </ul> <ul> <li> <p>Self Healing</p> <p>It has default settings that provide abilities such as:</p> <ul> <li>restart if containers fail</li> <li>reschedule the workloads when node goes down</li> <li>gracefully terminates the workloads that fail to attain the health check rule and makes them available to end users when they are ready to serve again</li> </ul> </li> </ul> <ul> <li> <p>Horizontal Scaling</p> <p>It allows your workloads to be scaled horizontally based on demand or on certain events that are configured by you</p> </li> </ul> <ul> <li> <p>Storage Management</p> <p>It mounts to the storage system of your choice while also taking care of their lifecycle</p> </li> </ul> <ul> <li> <p>Secret &amp; Configuration Management</p> <p>It allows you to create, update and consume the secrets and configuration required for your workloads without rebuilding its image and exposing the secrets as plain text</p> </li> </ul> <ul> <li> <p>Service Discovery and Load Balancing</p> <ul> <li>It comes with an out-of-the-box service discovery mechanism to discover your workloads</li> <li>It gives workloads their own IP addresses and a single DNS name for a set of workloads and can load balance across them</li> </ul> </li> </ul> <ul> <li> <p>Batch Execution</p> <p>It allows you to execute certain jobs until the desired result is attained</p> </li> </ul> <ul> <li> <p>IPv4 &amp; IPv6 Dual-stack</p> <p>It allocates IPv4 and IPv6 addresses to workloads</p> </li> </ul> <ul> <li> <p>Customization</p> <p>It is highly customizable and extensible without requiring you to submit a pull, merge or change request to the upstream source code</p> </li> </ul> <ul> <li> <p>Resource Management</p> <p>It schedules the workloads based on the resource requirements and constraints configured, while increasing consumption, saving resources and also providing high availability</p> </li> </ul>"},{"location":"concepts/components/","title":"Components","text":""},{"location":"concepts/components/#introduction","title":"Introduction","text":"<p>A Kubernetes consists of a single or set of compute machines and is referred to as <code>node(s)</code>.</p> <p>When these nodes are installed with Kubernetes and are interconnected with each other in the same isolated space, then it becomes a <code>cluster</code>. A cluster must have at least one node.</p> <p>A node consists of two types, and they are:</p> <ul> <li><code>worker node(s)</code> </li> <li><code>master node(s)</code></li> </ul> Note <p>When a cluster is created with one node, it acts as both a master node and a worker node.</p> <p>A Kubernetes comes with two components, and they are:</p> <ul> <li><code>Control plane components</code> which are installed on master node(s), and</li> <li><code>Data plane components</code> which are installed on worker node(s)</li> </ul>"},{"location":"concepts/components/#control-plane-components","title":"Control Plane Components","text":"<p>It consists of collection processes that are responsible for the global decisions of the cluster as well as detecting and responding to cluster events.</p> <p>Here are the processes that make up the control plane components and what they are responsible for:</p>"},{"location":"concepts/components/#kube-apiserver","title":"kube-apiserver","text":"<ul> <li>This component exposes the APIs of Kubernetes</li> <li>It is serves as the frontend for the control plane</li> <li>It is designed to scale horizontally and balance traffic between those scaled instances of the component</li> </ul>"},{"location":"concepts/components/#kube-scheduler","title":"kube-scheduler","text":"<ul> <li>It watches for newly created <code>Pods</code> that have not yet been assigned to a node and selects a node for it to run.</li> <li>There are several factors taken into consideration by this component, and they are:<ul> <li>Individual and collective resource requirements</li> <li>Hardware, software or policy constraints</li> <li>Affinity and anti-affinity configurations</li> <li>Data locality</li> <li>Deadlines</li> </ul> </li> </ul>"},{"location":"concepts/components/#kube-controller-manager","title":"kube-controller-manager","text":"<ul> <li>It runs controller processes</li> <li> <p>There are various types of controllers and some of them are:     -<code>Node</code> controller: Responsible for observing the nodes going down and triggering appropriate actions.     -<code>Job</code> controller: Responsible for observing <code>Job</code> objects and creating <code>Pods</code> to run those jobs to completion.     -<code>ServiceAccount</code> controller: Responsible for creating the default <code>ServiceAccount</code> for new namespaces.     -<code>EndpointSlice</code> controller: Responsible for populating <code>EndpointSlice</code> objects to provide links between <code>Services</code> and <code>Pods</code>.</p> Note <p>Each controller is a separate process; however, they are compiled into a single binary and run as a single process.</p> </li> </ul>"},{"location":"concepts/components/#etcd","title":"etcd","text":"<p>A highly available and consistent key-value store is used to persist the Kubernetes cluster data.</p> Tip <p>If you are using <code>etcd</code> as a backup store for Kubernetes cluster data, then ensure you have a backup plan for those data.</p>"},{"location":"concepts/components/#cloud-controller-manager","title":"cloud-controller-manager","text":"<ul> <li>It is a component that allows you to link your cluster with your cloud service provider's API</li> <li>It's only available if your cluster is created by one of the cloud service provider</li> <li>It is introduced to separate interaction with the cloud platform from interaction that is specific to cluster</li> <li> <p>There are various types of controllers, and some of them are:</p> <ul> <li><code>Node</code> controller: Responsible for verifying with the cloud service provider the state of the node when it is unresponsive</li> <li><code>Route</code> controller: Responsible for setting up routes in the underlaying cloud infrastructure</li> <li><code>Service</code> controller: Responsible for provisioning and de-provisioning cloud load balancers</li> </ul> Note <p>Each controller is a separate process; however, they are compiled into a single binary and run as a single process.</p> </li> </ul>"},{"location":"concepts/components/#data-plane-components","title":"Data Plane Components","text":"<p>The data plane components run on every worker node.</p>"},{"location":"concepts/components/#kubelet","title":"kubelet","text":"<ul> <li>It is responsible for ensuring that containers are running in <code>Pod</code></li> <li>It does it by reading the containers described in <code>PodSpecs</code></li> <li>It does not manage containers that are not created by Kubernetes</li> </ul>"},{"location":"concepts/components/#kube-proxy","title":"kube-proxy","text":"<ul> <li>It is a network proxy responsible for implementing certain parts of the <code>Service</code> object</li> <li>It maintains the network rules on worker nodes, which allows network communication to <code>Pods</code></li> <li>It uses the packet filtering layer of the operating system if it exists and is available to use; otherwise, it forwards the traffic by itself</li> </ul>"},{"location":"concepts/components/#container-runtime","title":"Container Runtime","text":"<ul> <li>It is responsible for managing the execution and lifecycle of containers within the Kubernetes</li> <li>There are various container runtime, and they are:<ul> <li>containerd</li> <li>cri-o</li> <li>Any container runtime that adheres to the <code>Container Runtime Interface</code></li> </ul> </li> </ul>"}]}